#!/usr/bin/env python

# A simple Git version script.
# Generates a C/C++ header with definitions.

import sys
import subprocess

# Configuration options
TRUNK = "master"
CC_NAMESPACE = "bf2mods::version"
C_PREFIX = "BF2MODS_VERSION"
DIRTY_CHAR = '~'

def output(command):
    return subprocess.run(command, shell=True, capture_output=True, text=True, check=True).stdout.replace('\n', '')

# Class representation of Git version information
class GitInfo:
    def __init__(self):
        self.commit = output("git rev-parse --short HEAD")
        self.branch = output("git rev-parse --abbrev-ref HEAD")
        self.tag = output(f"git describe --tags --always --dirty={DIRTY_CHAR}")

        self.trunkBuild = self.branch == TRUNK or self.branch == "HEAD"
        self.dirty = self.tag.endswith(DIRTY_CHAR)
        if self.dirty:
            self.commit += DIRTY_CHAR
        self.hasTag = self.commit != self.tag

        self.fullTag = self.getVersionTag()

    # Get a version tag.
    def getVersionTag(self):
        out = ""
        if self.trunkBuild:
            # we don't care if this is just a commit or is actually a tag
            # if it's dirty it'll give itself the tilde and everything
            out += self.tag
        else:
            # we do care here, however
            if self.hasTag:
                out += f"{self.tag}{'' if self.dirty else '-'}"

            out += f"{self.commit}{'' if self.dirty else '-'}"
            out += self.branch
        return out

def bool_to_cc(value):
    return str(value).lower()

"""
This is needed because in theory the header
can be included in a C program as well.

If it is, we cannot use true/false (unless we include <stdbool.h>),
so we use 0/1. They will do the right thing in the preprocessor contexts
they might be needed for, and should convert nicely back to booleans
(if that's so desired.)
"""
def bool_to_c(value):
    if value:
        return "1"
    return "0"

def usage(err):
    if err != None:
        print(f"Error: {err}")
    print(f"Usage: {sys.argv[0]} [path to Git version file]")
    print("Configuration: ")
    print(f"    Trunk branch: {TRUNK}")
    print(f"    C++ namespace: {CC_NAMESPACE}")
    print(f"    C macro prefix: {C_PREFIX}")
    print(f"    Dirty worktree indicator: {DIRTY_CHAR}")

def main():
    if not len(sys.argv) > 1:
        usage("Filename argument not provided")
        sys.exit(1)

    # Get Git version information
    info = GitInfo()

    with open(sys.argv[1], "w+") as file:
        file.write(f"""
// This file is generated by a script.
// Do not edit it, it will be rebuilt.

#pragma once

#ifdef __cplusplus
namespace {CC_NAMESPACE} {{
    inline constexpr char commit[] = "{info.commit}";
    inline constexpr char branch[] = "{info.branch}";
    inline constexpr char tag[] = "{info.tag}";
    inline constexpr char fullTag[] = "{info.fullTag}";
    
    inline constexpr bool isDirty = {bool_to_cc(info.dirty)};
    inline constexpr bool isTrunk = {bool_to_cc(info.trunkBuild)};
}}
#endif

#define {C_PREFIX}_GIT_COMMIT "{info.commit}"
#define {C_PREFIX}_GIT_BRANCH "{info.branch}"
#define {C_PREFIX}_GIT_TAG "{info.tag}" 
#define {C_PREFIX}_GIT_FULL_TAG "{info.fullTag}"

#define {C_PREFIX}_GIT_IS_DIRTY {bool_to_c(info.dirty)}
#define {C_PREFIX}_GIT_IS_TRUNK {bool_to_c(info.trunkBuild)}
        """)

if __name__ == "__main__":
    main()
